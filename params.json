{"name":"gp","tagline":"Gaussian process software in MATLAB.","body":"Gaussian Process Software\r\n=========================\r\n\r\nThis page describes examples of how to use the Gaussian Process Software (GP).\r\n\r\n\r\nRelease Information\r\n-------------------\r\n\r\n**Current release is 0.137**.\r\n\r\nAs well as downloading the GP software you need to obtain the toolboxes specified below. \r\n\r\n| **Toolbox**                                   | **Version** |\r\n|-----------------------------------------------|-------------|\r\n| [NETLAB](/netlab/downloadFiles/vrs3p3)        | 3.3         |\r\n| [MOCAP](/mocap/downloadFiles/vrs0p136)        | 0.136       |\r\n| [NDLUTIL](/ndlutil/downloadFiles/vrs0p162)    | 0.162       |\r\n| [PRIOR](/prior/downloadFiles/vrs0p22)         | 0.22        |\r\n| [MLTOOLS](/mltools/downloadFiles/vrs0p138)    | 0.138       |\r\n| [MOCAP](/mocap/downloadFiles/vrs0p136)        | 0.136       |\r\n| [OPTIMI](/optimi/downloadFiles/vrs0p132)      | 0.132       |\r\n| [DATASETS](/datasets/downloadFiles/vrs0p1371) | 0.1371      |\r\n| [KERN](/kern/downloadFiles/vrs0p226)          | 0.226       |\r\n| [NOISE](/noise/downloadFiles/vrs0p141)        | 0.141       |\r\n\r\nMinor updates to gpLoadResult for allowing different functions for loading in data.\r\n\r\n#### Version 0.136\r\n\r\nChanges to gpReadFromFID for compatibility with C++ code.\r\n\r\n#### Version 0.135\r\n\r\nModifications by Carl Henrik Ek for compatability with the SGPLVM toolbox.\r\n\r\n#### Version 0.134\r\n\r\nUpdates to allow deconstruction of model files when writing to disk (gpWriteResult, gpLoadResult, gpDeconstruct, gpReconstruct).\r\n\r\n#### Version 0.133\r\n\r\nUpdates for running a GPLVM/GP using the data's inner product matrix for Interspeech synthesis demos.\r\n\r\n#### Version 0.132\r\n\r\nExamples transfered from oxford toolbox, variational approximation from Titsias added as an option with 'dtcvar'.\r\n\r\n#### Version 0.131\r\n\r\nChanges to allow compatibility with SGPLVM and NCCA toolboxes.\r\n\r\n#### Version 0.13\r\n\r\nChanges to allow more flexibility in optimisation of beta.\r\n\r\n#### Version 0.12\r\n\r\nVarious minor changes for enabling back constraints in hierarchical GP-LVM models.\r\n\r\n#### Version 0.11\r\n\r\nChanges include the use of the optimiDefaultConstraint('positive') to obtain the function to constrain beta to be positive (which now returns 'exp' rather than 'negLogLogit' which was previously the default). Similarly default optimiser is now given by a command in optimiDefaultOptimiser.\r\n\r\n#### Version 0.1\r\n\r\nThe first version which is spun out of the FGPLVM toolbox. The corresponding FGPLVM toolbox is 0.15.\r\n\r\nRelease 0.1 splits away the Gaussian process section of the FGPLVM toolbox into this separate toolbox.\r\n\r\nOther GP related software\r\n-------------------------\r\n\r\nThe GP-LVM C++ software is available from [here](/gplvmcpp/).\r\n\r\nThe IVM C++ software is available from [here](/ivmcpp/).\r\n\r\nThe MATLAB IVM toolbox is available here [here](/ivm/).\r\n\r\nThe original MATLAB GP-LVM toolbox is available here [here](/gplvm/).\r\n\r\nExamples\r\n--------\r\n\r\n### Functions from Gaussians\r\n\r\nThis example shows how points which look like they come from a function to be sampled from a Gaussian distribution. The sample is 25 dimensional and is from a Gaussian with a particular covariance.\r\n\r\n```matlab\r\n>> demGpSample\r\n```\r\n\r\n![](gpSample.png)![](gpCovariance.png)\r\n\r\n*Left* A single, 25 dimensional, sample from a Gaussian distribution. *Right* the covariance matrix of the Gaussian distribution..\r\n### Joint Distribution over two Variables\r\n\r\nGaussian processes are about conditioning a Gaussian distribution on the training data to make the test predictions. To illustrate this process, we can look at the joint distribution over two variables.\r\n\r\n```matlab\r\n>> demGpCov2D([1 2])\r\n```\r\n\r\nGives the joint distribution for *f*<sub>1</sub> and *f*<sub>2</sub>. The plots show the joint distributions as well as the conditional for *f*<sub>2</sub> given *f*<sub>1</sub>.\r\n\r\n![](demGpCov2D1_2_3.png)![](demGpCov2D1_5_3.png)\r\n\r\n*Left* Blue line is contour of joint distribution over the variables *f*<sub>1</sub> and *f*<sub>2</sub>. Green line indicates an observation of *f*<sub>1</sub>. Red line is conditional distribution of *f*<sub>2</sub> given *f*<sub>1</sub>. *Right* Similar for *f*<sub>1</sub> and *f*<sub>5</sub>.\r\n### Different Samples from Gaussian Processes\r\n\r\nA script is provided which samples from a Gaussian process with the provided covariance function.\r\n\r\n```matlab\r\n>> gpSample('rbf', 10, [1 1], [-3 3], 1e5)\r\n```\r\n\r\nwill give 10 samples from an RBF covariance function with a parameter vector given by [1 1] (inverse width 1, variance 1) across the range -3 to 3 on the *x*-axis. The random seed will be set to 1e5.\r\n\r\n```\r\n>> gpSample('rbf', 10, [16 1], [-3 3], 1e5)\r\n```\r\nis similar, but the inverse width is now set to 16 (length scale 0.25).\r\n\r\n![](gpSampleRbfSamples10Seed100000InverseWidth1Variance1.png)![](gpSampleRbfSamples10Seed100000InverseWidth16Variance1.png)\r\n\r\n*Left* samples from an RBF style covariance function with length scale 1. *Right* samples from an RBF style covariance function with length scale 0.25.\r\nOther covariance functions can be sampled, an interesting one is the MLP covariance which is non stationary and can produce point symmetric functions,\r\n\r\n```matlab\r\n>> gpSample('mlp', 10, [100 100 1], [-1 1], 1e5)\r\n```\r\n\r\ngives 10 samples from the MLP covariance function where the \"bias variance\" is 100 (basis functions are centered around the origin with standard deviation of 10) and the \"weight variance\" is 100.\r\n\r\n```matlab\r\n>> gpSample('mlp', 10, [100 1e-16 1], [-1 1], 1e5)\r\n```\r\n\r\ngives 10 samples from the MLP covariance function where the \"bias variance\" is approximately zero (basis functions are placed on the origin) and the \"weight variance\" is 100.\r\n\r\n![](gpSampleMlpSamples10Seed100000WeightVariance100BiasVariance100Variance1.png)![](gpSampleMlpSamples10Seed100000WeightVariance100BiasVariance1e-16Variance1.png)\r\n\r\n*Left* samples from an MLP style covariance function with bias and weight variances set to 100. *Right* samples from an MLP style covariance function with weight variance 100 and bias variance approximately zero.\r\n### Posterior Samples\r\n\r\nGaussian processes are non-parametric models. They are specified by their covariance function and a mean function. When combined with data observations a posterior Gaussian process is induced. The demos below show samples from that posterior.\r\n\r\n```matlab\r\n>> gpPosteriorSample('rbf', 5, [1 1], [-3 3], 1e5)\r\n```\r\n\r\nand\r\n\r\n```matlab\r\n>> gpPosteriorSample('rbf', 5, [16 1], [-3 3], 1e5)\r\n```\r\n\r\n![](gpPosteriorSampleRbfSamples5Seed100000InverseWidth1Variance1bw.png)![](gpPosteriorSampleRbfSamples5Seed100000InverseWidth16Variance1bw.png)\r\n\r\n*Left* samples from the posterior induced by an RBF style covariance function with length scale 1 and 5 \"training\" data points taken from a sine wave. *Right* Similar but for a length scale of 0.25.\r\n\r\n### Simple Interpolation Demo\r\n\r\nThis simple demonstration plots, consecutively, an increasing number of data points, followed by an interpolated fit through the data points using a Gaussian process. This is a noiseless system, and the data is sampled from a GP with a known covariance function. The curve is then recovered with minimal uncertainty after only nine data points are included. The code is run with\r\n\r\n```matlab\r\n>> demInterpolation\r\n```\r\n\r\n![](demInterpolation3.png)![](demInterpolation4.png)\r\n Gaussian process prediction *left* after two points with a new data point sampled *right* after the new data point is included in the prediction.\r\n ![](demInterpolation7.png)![](demInterpolation8.png)\r\n\r\nGaussian process prediction *left* after five points with a four new data point sampled *right* after all nine data points are included.\r\n\r\n### Simple Regression Demo\r\n\r\nThe regression demo very much follows the format of the interpolation demo. Here the difference is that the data is sampled with noise. Fitting a model with noise means that the regression will not necessarily pass right through each data point. The code is run with\r\n\r\n```matlab\r\n>> demRegression\r\n```\r\n\r\n![](demRegression3.png)![](demRegression4.png)\r\n Gaussian process prediction *left* after two points with a new data point sampled *right* after the new data point is included in the prediction.\r\n ![](demRegression7.png)![](demRegression8.png)\r\n\r\nGaussian process prediction *left* after five points with a four new data point sampled *right* after all nine data points are included.\r\n\r\n### Optimizing Hyper Parameters\r\n\r\nOne of the advantages of Gaussian processes over pure kernel interpretations of regression is the ability to select the hyper parameters of the kernel automatically. The demo\r\n\r\n```matlab\r\n>> demOptimiseGp\r\n```\r\n\r\nshows a series of plots of a Gaussian process with different length scales fitted to six data points. For each plot there is a corresponding plot of the log likelihood. The log likelihood peaks for a length scale equal to 1. This was the length scale used to generate the data.\r\n\r\n![](demOptimiseGp1.png)![](demOptimiseGp3.png)![](demOptimiseGp5.png)\r\n![](demOptimiseGp7.png)![](demOptimiseGp9.png)![](demOptimiseGp11.png)\r\n![](demOptimiseGp13.png)![](demOptimiseGp15.png)![](demOptimiseGp17.png)\r\n\r\nFrom top left to bottom right, Gaussian process regression applied to the data with an increasing length scale. The length scales used were 0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8 and 16.\r\n\r\n![](demOptimiseGp18.png)\r\n\r\nLog-log plot of the log likelihood of the data against the length scales. The log likelihood is shown as a solid line. The log likelihood is made up of a data fit term (the quadratic form) shown by a dashed line and a complexity term (the log determinant) shown by a dotted line. The data fit is larger for short length scales, the complexity is larger for long length scales. The combination leads to a maximum around the true length scale value of 1.\r\n\r\n### Regression over Motion Capture Markers\r\n\r\nAs a simple example of regression for real data we consider a motion capture data set. The data is [from Ohio State University](http://accad.osu.edu/research/mocap/mocap_data.htm). In the example script we perform Gaussian process regression with time as the input and the x,y,z position of the marker attached to the left ankle. To demonstrate the behavior of the model when the marker is lost, we remove data from This code can be run with\r\n\r\n```matlab\r\n>> demStickGp1 \r\n```\r\n\r\nThe code will optimize hyper parameters and show plots of the posterior process through the training data and the missing test points.\r\n\r\nThe result of the script is given in the plot below.\r\n\r\n![](demStickGp1Out1.png) ![](demStickGp1Out2.png) ![](demStickGp1Out3.png)\r\n\r\nGaussian process regression through the x (left), y (middle) and z (right) position of the left ankle. Training data is shown as black spots, test points removed to simulate a lost marker are shown as circles, posterior mean prediction is shown as a black line and two standard deviations are given as grey shading.\r\nNotice how the error bars are tight except in the region where the training data is missing and in the region where the training data disappears.\r\n\r\n### Sparse Pseudo-input Gaussian Processes\r\n\r\nThe sparse approximation used in this toolbox is based on the Sparse Pseudo-input Gaussian Process model described by [Snelson and Ghahramani](/neill-bin/publications/bibpage.cgi?keyName=Snelson:pseudo05&printAbstract=1). Also provided are the extensions suggested by [Quiñonero-Candela and Rasmussen](/neill-bin/publications/bibpage.cgi?keyName=Quinonero:unifying05). They provide a unifying terminology for describing these approximations which we shall use in what follows.\r\n\r\nThere are three demos provided for Gaussian process regression in 1-D. They each use a different form of likelihood approximation. The first demonstration uses the \"projected latent variable\" approach first described by [Csato and Opper](/neill-bin/publications/bibpage.cgi?keyName=Csato:sparse02&printAbstract=1) and later used by [Seeger *et al.*](/neill-bin/publications/bibpage.cgi?keyName=Seeger:fast03&printAbstract=1). In the terminology of Quiñonero-Candela and Rasmussen (QR-terminology) this is known as the \"deterministic training conditional\" (DTC) approximation.\r\n\r\nTo use this approximation the following script can be run.\r\n\r\n```matlab\r\n>> demSpgp1dGp1 \r\n```\r\n\r\nThe result of the script is given in the plot below.\r\n\r\n![](demSpgp1dGp1.png)\r\n\r\nGaussian process using the DTC approximation with nine inducing variables. Data is shown as black spots, posterior mean prediction is shown as a black line and two standard deviations are given as grey shading.\r\nThe improved approximation suggested by Snelson and Ghahramani, in QR-terminology this is known as the fully independent training conditional (FITC). To try this approximation run the following script\r\n\r\n```matlab\r\n>> demSpgp1dGp2 \r\n```\r\n\r\nThe result of the script is given on the left of the plot below.\r\n\r\n![](demSpgp1dGp2.png)![](demSpgp1dGp3.png)\r\n\r\n*Left*: Gaussian process using the FITC approximation with nine inducing variables. Data is shown as black spots, posterior mean prediction is shown as a black line and two standard deviations are given as grey shading. *Right*: Similar but for the PITC approximation, again with nine inducing variables.\r\nAt the [Sheffield Gaussian Process Round Table](http://www.dcs.shef.ac.uk/ml/gprt/) Lehel Csato pointed out that the Bayesian Committee Machine of [Schwaighofer and Tresp](/neill-bin/publications/bibpage.cgi?group=bcm&printAbstract=1) can also be viewed within the same framework. This idea is formalised in [Quiñonero-Candela and Rasmussen's](/neill-bin/publications/bibpage.cgi?keyName=Quinonero:unifying05&printAbstract=1) review. This approximation is known as the \"partially independent training conditional\" (PITC) in QR-terminology. To try this approximation run the following script\r\n\r\n```matlab\r\n>> demSpgp1dGp3\r\n```\r\n\r\nThe result of the script is given on the right of the plot above.\r\n\r\nFinally we can compare these results to the result from the full Gaussian process on the data with the correct hyper-parameters. To do this the following script can be run.\r\n\r\n```matlab\r\n>> demSpgp1dGp4\r\n```\r\n\r\nThe result of the script is given in the plot below.\r\n\r\n![](demSpgp1dGp4.png)\r\n\r\nFull Gaussian process on the toy data with the correct hyper-parameters. Data is shown as black spots, posterior mean prediction is shown as a black line and two standard deviations are given as grey shaded area.\r\n\r\nPage updated on Fri Jul 22 16:22:15 2011\r\n","google":"UA-62968536-1","note":"Don't delete this file! It's used internally to help with page regeneration."}